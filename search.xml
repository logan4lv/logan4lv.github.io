<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap</title>
    <url>/2021/07/08/2021-07-08-HashMap/</url>
    <content><![CDATA[<p>近期准备出来面试，在这里将 HashMap 的底层逻辑整理一下，做个笔记。内容以问答的形式来组织，通过一问一答来解释 HashMap 的实现细节。</p>
<span id="more"></span>

<h3 id="1-底层数据结构是什么？"><a href="#1-底层数据结构是什么？" class="headerlink" title="1. 底层数据结构是什么？"></a>1. 底层数据结构是什么？</h3><p>JDK 1.8 之前 HashMap 的数据结构为 “ 数组 + 链表”。到了 JDK 1.8 后，改为了 “数组 + 链表 + 红黑树”。</p>
<h3 id="2-JDK-1-8-为什么会引入红黑树？"><a href="#2-JDK-1-8-为什么会引入红黑树？" class="headerlink" title="2. JDK 1.8 为什么会引入红黑树？"></a>2. JDK 1.8 为什么会引入红黑树？</h3><p>链表的查询时间复杂度为 O(n)</p>
<p>红黑树的查询时间复杂度为 O(log<sup>n</sup>)</p>
<p>当哈希冲突变严重时，哈希桶中的链表会很长，这时如果将链表转化为红黑树，会提升查询性能。 </p>
<h3 id="3-链表和红黑树相互转化的条件？"><a href="#3-链表和红黑树相互转化的条件？" class="headerlink" title="3. 链表和红黑树相互转化的条件？"></a>3. 链表和红黑树相互转化的条件？</h3><p>链表 → 红黑树，需要满足两个条件：capacity &gt;= 64 &amp; 哈希桶中的元素数量大于8。当 capacity &lt; 64 时，优先进行扩容。</p>
<p>红黑树 → 链表，需要满足一个条件：哈希桶中的元素数量 = 6。</p>
<p>条件设置为8的原因：</p>
<blockquote>
<p>空间和时间的权衡，当元素数量较少时，浪费空间（红黑树的占用空间是链表的2倍），并且查询性能也没有明显的提升。</p>
</blockquote>
<p>条件设置为6的原因：</p>
<blockquote>
<p>如果哈希桶中的元素数量一直在8徘徊，链表和红黑树的频繁转化会产生性能问题。</p>
</blockquote>
<p><strong>变量说明:</strong></p>
<ul>
<li><p>capacity：容量，哈希桶的数量，基于initial capacity，每次扩容两倍</p>
</li>
<li><p>size：元素数量</p>
</li>
<li><p>load factor：负载因子，当 size &gt;= capacity * loadfactor 时，进行容量扩容</p>
</li>
<li><p>threshold：阈值，capacity * loadfactor</p>
</li>
<li><p>initialCapacity 构造器传入的初始容量</p>
</li>
</ul>
<h3 id="4-构造器"><a href="#4-构造器" class="headerlink" title="4. 构造器"></a>4. 构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始容量 initialCapacity 要合理的设置，提前预估出要放置的元素数量，避免后面不断扩容，引发性能损耗。例：假设使用无参构造的 HashMap 存放1000个元素，需要扩容7次才能完成存储。</p>
<p>初始化时，根据构造器入参 initialCapacity 计算比它大的2的整数次幂的容量大小，然后存入threshold中，在第一次 put 的时候根据 threshold 来初始化数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123; <span class="comment">// 假设入参 cap = 11，二进制为 1011</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">// 避免cap为2的整数次幂数，n = 10，二进制为 1010</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 无符号右移，高位补0，n &gt;&gt;&gt; 1 为 0101，OR操作后，n的二进制为 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// n &gt;&gt;&gt; 2 为 0011，OR操作后，ｎ的二进制为 1111</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">// 最终 n 为 1111</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; <span class="comment">// n + 1 = 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不断的无符号右移 &gt;&gt;&gt; 及 | 的操作将n的低位转为1，最后+1转为2的整数次幂。</p>
<h3 id="5-为什么capacity为2的整数次幂"><a href="#5-为什么capacity为2的整数次幂" class="headerlink" title="5. 为什么capacity为2的整数次幂"></a>5. 为什么capacity为2的整数次幂</h3><p>在 HashMap 中，get 操作需要根据 hash(key) mod capacity 来取模，计算key是在哪个桶中。</p>
<p>由于 % 是比较慢的操作， get 是频繁的操作，所以如果用 % 取模，会有性能问题。</p>
<p>如果容量设置为 2 的整数次幂，取余操作可以使用掩码操作，公式 <strong>x mod 2<sup>n</sup> = x &amp; (2<sup>n</sup> - 1)</strong></p>
<blockquote>
<p><strong>index = hash(key) &amp; (capacity - 1)</strong></p>
</blockquote>
<h3 id="6-为什么计算-hash-key-时，要将-hashCode-的高16位无符号右移"><a href="#6-为什么计算-hash-key-时，要将-hashCode-的高16位无符号右移" class="headerlink" title="6. 为什么计算 hash(key) 时，要将 hashCode 的高16位无符号右移"></a>6. 为什么计算 hash(key) 时，要将 hashCode 的高16位无符号右移</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 hashCode 的高16位与本身进行异或操作，可以让高16位也参与进hash值的计算。</p>
<p>当 capacity = 16 时，capacity - 1 二进制形式为 <strong>0000 1111</strong>，做&amp;操作时只会对 hash(key) 的低4位产生影响，所以索引的计算结果只取决于hash值得低4位，让高位参与运算就不会只取决于低4位</p>
<h3 id="7-put操作的逻辑"><a href="#7-put操作的逻辑" class="headerlink" title="7. put操作的逻辑"></a>7. put操作的逻辑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 判断散列表是否为空，空则执行resize()进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 取模找桶，判断桶中是否有元素，没有则直接存放</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 桶中已有元素，出现hash冲突</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断和桶中已有的元素是否为同一个，先比较hash，再比较key</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断桶中已有元素是否为红黑树节点，是则将元素放进红黑树中，</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 此时，桶中结构为链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 大循环，0代表第一个元素，7代表第8个元素</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 判断p是否为链表最后一个元素</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st，判断是否已遍历到链表第8个元素</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断和桶中已有的元素是否为同一个，先比较hash，再比较key</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key，前面如果找出相同元素，会存放到变量e中</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 如果元素容量大于阈值，则进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Object类定义中对hashCode和equals的要求如下:</strong></p>
<ol>
<li><p>如果两个对象的 equals 的结果是相等的，则两个对象的 hashCode 的返回结果也必须是相等的。</p>
</li>
<li><p>任何时候覆写 equals，都必须同时覆写 hashCode 。</p>
</li>
</ol>
<h3 id="8-resize操作的逻辑"><a href="#8-resize操作的逻辑" class="headerlink" title="8. resize操作的逻辑"></a>8. resize操作的逻辑</h3><p><strong>触发时机：</strong></p>
<ul>
<li>第一次put的时候，此时数组没有初始化。需要初始化数组，长度为threshold</li>
<li>当hash桶中冲突严重，达到8的阈值时，如果此时capacity小于64，则进行resize，否则转为红黑树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 做哈希桶的初始化，或者做2倍扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 做2倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 此时不做扩容，将阈值设置为整型最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  <span class="comment">// 没有设置过newThr值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 产生新的阈值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 取出第一个元素</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>; <span class="comment">// 将旧数组对应下标置为null，便于回收</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 只有一个元素时，直接放置到新的数组中</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 为红黑树时</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 定位到最后一个元素</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JDK API</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
</search>
